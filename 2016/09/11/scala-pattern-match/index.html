<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Scala的模式匹配 | Ling0fa 的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文主要总结模式匹配的用法。 本文内容摘自《Scala程序设计》[美]Dean Wampler Alex Payne，版权归原作者所有。
Scala的模式匹配有点像以前接触的switch-case语句，但功能比switch-case丰富很多，是一种强大的“协议”。
1、简单匹配123456789val bools = Seq(true, false)for (bool &amp;lt;- bools) &amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala的模式匹配">
<meta property="og:url" content="http://yoursite.com/2016/09/11/scala-pattern-match/index.html">
<meta property="og:site_name" content="Ling0fa 的博客">
<meta property="og:description" content="本文主要总结模式匹配的用法。 本文内容摘自《Scala程序设计》[美]Dean Wampler Alex Payne，版权归原作者所有。
Scala的模式匹配有点像以前接触的switch-case语句，但功能比switch-case丰富很多，是一种强大的“协议”。
1、简单匹配123456789val bools = Seq(true, false)for (bool &amp;lt;- bools) &amp;">
<meta property="og:updated_time" content="2018-07-17T14:11:09.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Scala的模式匹配">
<meta name="twitter:description" content="本文主要总结模式匹配的用法。 本文内容摘自《Scala程序设计》[美]Dean Wampler Alex Payne，版权归原作者所有。
Scala的模式匹配有点像以前接触的switch-case语句，但功能比switch-case丰富很多，是一种强大的“协议”。
1、简单匹配123456789val bools = Seq(true, false)for (bool &amp;lt;- bools) &amp;">
  
    <link rel="alternate" href="/atom.xml" title="Ling0fa 的博客" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  

</head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">Ling0fa 的博客</h1>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          <article id="post-scala-pattern-match" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 class="article-title" itemprop="name">
      Scala的模式匹配
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2016/09/11/scala-pattern-match/" class="article-date"><time datetime="2016-09-11T06:01:09.000Z" itemprop="datePublished">2016-09-11</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p><em>本文主要总结模式匹配的用法。<br> 本文内容摘自《Scala程序设计》[美]Dean Wampler Alex Payne，版权归原作者所有。</em></p>
<p>Scala的模式匹配有点像以前接触的switch-case语句，但功能比switch-case丰富很多，是一种强大的“协议”。</p>
<h3 id="1、简单匹配"><a href="#1、简单匹配" class="headerlink" title="1、简单匹配"></a>1、简单匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> bools = <span class="type">Seq</span>(<span class="literal">true</span>, <span class="literal">false</span>)</div><div class="line"><span class="keyword">for</span> (bool &lt;- bools) &#123;</div><div class="line">  bool <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="literal">true</span> =&gt; println(<span class="string">"hello"</span>)</div><div class="line">    <span class="keyword">case</span> <span class="literal">false</span> =&gt; println(<span class="string">"world"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// hello</span></div><div class="line"><span class="comment">// world</span></div></pre></td></tr></table></figure>
<p>case后面没有跟break语句。如果将上面任意一个case语句注释，编译器会抛出MatchError，因为case语句没有包含所有可能出现的情况。</p>
<h3 id="2、match中的值、变量和类型"><a href="#2、match中的值、变量和类型" class="headerlink" title="2、match中的值、变量和类型"></a>2、match中的值、变量和类型</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">  x &lt;- <span class="type">Seq</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3.7</span>, <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="symbol">'four</span>)</div><div class="line">&#125; &#123;</div><div class="line">  <span class="keyword">val</span> str = x <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>          =&gt; <span class="string">"int 1"</span></div><div class="line">    <span class="keyword">case</span> i: <span class="type">Int</span>     =&gt; <span class="string">"other int :"</span> + i                <span class="comment">// 除1以外的所有整数</span></div><div class="line">    <span class="keyword">case</span> d: <span class="type">Double</span>  =&gt; <span class="string">"a double:"</span> + d</div><div class="line">    <span class="keyword">case</span> <span class="string">"one"</span>      =&gt; <span class="string">"String one"</span></div><div class="line">    <span class="keyword">case</span> s: <span class="type">String</span>  =&gt; <span class="string">"other string:"</span> + s</div><div class="line">    <span class="keyword">case</span> unexpected =&gt; <span class="string">"unexpected value:"</span> + unexpected <span class="comment">// 匹配其他的情况，x的值赋值给unexpected，类型为Any</span></div><div class="line">  &#125;</div><div class="line">  println(str)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意上面序列最后一个是Scala的Symbol对象。str的类型是所有case语句返回值类型的最近公共父类。另外，<strong>匹配具体的case语句要出现在匹配宽泛的case语句前</strong>，否则具体的case语句永远没有机会匹配上（编译器也可以识别这种错误）。在匹配Double类型时，为了避免舍入误差导致的无法匹配，可以使用下面的方式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">  x &lt;- <span class="type">Seq</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3.7</span>, <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="symbol">'four</span>)</div><div class="line">&#125; &#123;</div><div class="line">  <span class="keyword">val</span> str = x <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>          =&gt; <span class="string">"int 1"</span></div><div class="line">    <span class="keyword">case</span> _: <span class="type">Int</span>     =&gt; <span class="string">"other int :"</span> + x                </div><div class="line">    <span class="keyword">case</span> _: <span class="type">Double</span>  =&gt; <span class="string">"a double:"</span> + x</div><div class="line">    <span class="keyword">case</span> <span class="string">"one"</span>      =&gt; <span class="string">"String one"</span></div><div class="line">    <span class="keyword">case</span> _: <span class="type">String</span>  =&gt; <span class="string">"other string:"</span> + x</div><div class="line">    <span class="keyword">case</span> _          =&gt; <span class="string">"unexpected value:"</span> + x</div><div class="line">  &#125;</div><div class="line">  println(str)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面使用占位符<code>_</code>替代了变量，使用x来获取匹配的值。编写case语句时有个陷阱，就是编译器会假定大写字母开头的是类型名，小写字母开头的是变量名。如果要引用在前面定义的变量时，用反引号将其括起来，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkY</span></span>(y:<span class="type">Int</span>) = &#123;</div><div class="line">  <span class="keyword">for</span> &#123;</div><div class="line">    x &lt;- <span class="type">Seq</span>(<span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>)</div><div class="line">  &#125; &#123;</div><div class="line">    <span class="keyword">val</span> str = x <span class="keyword">match</span> &#123;</div><div class="line">      <span class="keyword">case</span> `y` =&gt; <span class="string">"found y!"</span></div><div class="line">      <span class="keyword">case</span> i:<span class="type">Int</span> =&gt; <span class="string">"found other"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有时不同的匹配语句需要处理相同的逻辑代码，为了避免冗余，可以使用“|”符号：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> str = x <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> _:<span class="type">Int</span> | <span class="keyword">case</span> _:<span class="type">Double</span> =&gt; <span class="string">"found number:"</span> + x</div><div class="line">  <span class="keyword">case</span> _:<span class="type">Any</span> =&gt; <span class="string">"found other"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、序列的匹配"><a href="#3、序列的匹配" class="headerlink" title="3、序列的匹配"></a>3、序列的匹配</h3><p>先看一个Scala的语法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x +: y = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line"><span class="comment">// x: Int = 1</span></div><div class="line"><span class="comment">// y: List[Int] = List(2, 3)</span></div></pre></td></tr></table></figure>
<p>这里的<code>+:</code>是序列的构造操作符（其实就是一个方法），Scala里以<code>:</code>结尾的方法是向右结合的，所有x只有一个头部，y包含整个尾部。类似的还有<code>++:</code>、<code>/:</code>等。对序列就可以这样匹配：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">seqToString</span></span>[<span class="type">T</span>](seq: <span class="type">Seq</span>[<span class="type">T</span>]): <span class="type">String</span> = seq <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> head +: tail =&gt; <span class="string">s"<span class="subst">$head</span> +: "</span> + seqToString(tail)</div><div class="line">  <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="string">"Nil"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">seqToString(<span class="type">Seq</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>))</div><div class="line"><span class="comment">// String = 2 +: 3 +: 4 +: 1 +: Nil</span></div></pre></td></tr></table></figure>
<p>上面使用<code>+:</code>来<strong>提取</strong>序列的头部和尾部放到head和tail变量里，Seq里也有head和tail方法，和这里的是不一样概念。返回的字符串是头部加尾部的递归调用返回的结果。下面是用Nil来匹配空序列。两个case语句包含了序列可能出现的所有可以匹配的情况，怎么理解呢，序列要么包含一个以上的元素，要么为空，非空的时候可以调用<code>+:</code>，匹配第一个case，空的时候就匹配第二个case，相当于分而治之的思想。<br><code>+:</code>其实是一个单例对象，这个类型只有一个方法，即编译器在case语句中用来提取数据的unapply方法，unapply的示意（非完整）如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>[<span class="type">T</span>, <span class="type">Coll</span>](collection:<span class="type">Coll</span>):<span class="type">Option</span>[(<span class="type">T</span>, <span class="type">Coll</span>)]</div></pre></td></tr></table></figure>
<p>头部类型被推断为T，剩余部分的类型和序列本身类型一致（可能为空序列）。<code>case head +: tail =&gt; …</code>是中缀表达式的写法，对应的形式是<code>case +:(head, tail)</code>，真正调用是<code>+:.unapply(collection)</code>。相对的，使用<code>:+</code>可以达到相反的效果，<code>prefix :+ end</code>前后两个变量分别提取了前N-1个元素和最后一个元素。   </p>
<p>为什么返回的是Option呢？其实这是为了允许在自定义unapply里返回需要的属性，对外隐藏内部的细节，比如年龄、住址什么的，当然也有可能返回None。</p>
<h3 id="4、元组的匹配"><a href="#4、元组的匹配" class="headerlink" title="4、元组的匹配"></a>4、元组的匹配</h3><p>直接举栗子把：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> langs = <span class="type">Seq</span>(</div><div class="line">  (<span class="string">"Scala"</span>, <span class="string">"Martin"</span>),</div><div class="line">  (<span class="string">"Clojure"</span>, <span class="string">"Rich"</span>),</div><div class="line">  (<span class="string">"Lisp"</span>, <span class="string">"John"</span>)</div><div class="line">)</div><div class="line"><span class="keyword">for</span> (tuple &lt;- langs) &#123;</div><div class="line">  tuple <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> (_, <span class="string">"Martin"</span>) =&gt; println(<span class="string">"found Scala"</span>)</div><div class="line">    <span class="keyword">case</span> (lang, name) =&gt; println(<span class="string">s"found other language:<span class="subst">$lang</span> (<span class="subst">$name</span>)"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>匹配元组时可以匹配一部分，lang和name都被推断为String。</p>
<h3 id="5、case中的guard语句"><a href="#5、case中的guard语句" class="headerlink" title="5、case中的guard语句"></a>5、case中的guard语句</h3><p>和for推导式中一样，case语句也可以有guard语句。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i &lt;- <span class="type">Seq</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)) &#123;</div><div class="line">  i <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> _ <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> =&gt; println(<span class="string">"even"</span>)</div><div class="line">    <span class="keyword">case</span> _               =&gt; println(<span class="string">"odd"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6、case类的匹配"><a href="#6、case类的匹配" class="headerlink" title="6、case类的匹配"></a>6、case类的匹配</h3><p>case类的成员都是val修饰的，所以类的对象和元组有点像。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span>(<span class="params">street:<span class="type">String</span>, city:<span class="type">String</span>, country:<span class="type">String</span></span>)</span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name:<span class="type">String</span>, age:<span class="type">Int</span>, address:<span class="type">Address</span></span>)</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> alice = <span class="type">Person</span>(<span class="string">"Alice"</span>, <span class="number">25</span>, <span class="type">Address</span>(<span class="string">"1 Lane"</span>, <span class="string">"Chicago"</span>, <span class="string">"USA"</span>))</div><div class="line"><span class="keyword">val</span> bob   = <span class="type">Person</span>(<span class="string">"Bob"</span>, <span class="number">33</span>, <span class="type">Address</span>(<span class="string">"2 Ave"</span>, <span class="string">"Miami"</span>, <span class="string">"USA"</span>))</div><div class="line"><span class="keyword">val</span> charlie = <span class="type">Person</span>(<span class="string">"Charlie"</span>, <span class="number">21</span>, <span class="type">Address</span>(<span class="string">"3 Ct"</span>, <span class="string">"Boston"</span>, <span class="string">"USA"</span>))</div><div class="line"></div><div class="line"><span class="keyword">for</span> (person &lt;- <span class="type">Seq</span>(alice, bob, charlie)) &#123;</div><div class="line">  person <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Person</span>(<span class="string">"Alice"</span>, <span class="number">25</span>, <span class="type">Address</span>(_, <span class="string">"Chicago"</span>, _)) =&gt; println(<span class="string">"hi Alice"</span>)</div><div class="line">    <span class="keyword">case</span> <span class="type">Person</span>(<span class="string">"Bob"</span>, <span class="number">33</span>, <span class="type">Address</span>(<span class="string">"2 Ave"</span>, <span class="string">"Miami"</span>, <span class="string">"USA"</span>)) =&gt; println(<span class="string">"hi bob"</span>)</div><div class="line">    <span class="keyword">case</span> <span class="type">Person</span>(name, age, _) =&gt; println(<span class="string">s"who is <span class="subst">$name</span>, age is <span class="subst">$age</span>"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里和匹配元组类似，也用了通配符，匹配需要的部分。最后一条匹配其余的情况。匹配case类的原理，其实是调用了case类的unapply方法，返回Option[TupleN[ ]]，N表示类里成员变量个数。</p>
<h3 id="7、可变参数列表的匹配"><a href="#7、可变参数列表的匹配" class="headerlink" title="7、可变参数列表的匹配"></a>7、可变参数列表的匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> lists = <span class="type">Seq</span>(</div><div class="line">  <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),</div><div class="line">  <span class="type">List</span>(<span class="number">4</span>,<span class="number">5</span>)</div><div class="line">)</div><div class="line"><span class="keyword">for</span> (list &lt;- lists) &#123;</div><div class="line">  list <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">List</span>(_, _)         =&gt; println(<span class="string">"2 elements"</span>)</div><div class="line">    <span class="keyword">case</span> <span class="type">List</span>(<span class="number">1</span>, vals @ _*) =&gt; println(<span class="string">"tail:"</span> + vals)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// tail:List(2, 3)</span></div><div class="line"><span class="comment">// 2 elements</span></div></pre></td></tr></table></figure>
<h3 id="8、正则表达式的匹配"><a href="#8、正则表达式的匹配" class="headerlink" title="8、正则表达式的匹配"></a>8、正则表达式的匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> bookRE = <span class="string">""</span><span class="string">"Book: title=([^,]+),\s+issue=(.+)"</span><span class="string">""</span>.r   <span class="comment">// 创建一个正则表达式</span></div><div class="line"><span class="keyword">val</span> catalog = <span class="string">"Book: title=Programming Scala, author=Deam Wampler"</span></div><div class="line"></div><div class="line">catalog <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> bookRE(title, author) =&gt; println(<span class="string">"title is $titile,author is $author"</span>)</div><div class="line">  <span class="keyword">case</span> notmatch              =&gt; println(<span class="string">"not match"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里用title和author来在匹配的同时，提取对应的字符串。</p>
<h3 id="9、模式匹配的漏洞"><a href="#9、模式匹配的漏洞" class="headerlink" title="9、模式匹配的漏洞"></a>9、模式匹配的漏洞</h3><p>考虑下面的匹配语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x match &#123;</div><div class="line">  case s1:Seq[Double] =&gt; println(&quot;Double&quot;)</div><div class="line">  case s2:Seq[String] =&gt; println(&quot;String&quot;)</div><div class="line">  case _              =&gt; println(&quot;unkonwn&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的匹配语句看似没什么问题，其实编译会产生告警。问题出在JVM的类型擦除机制，所以编译器认为第二个case语句不可达。有一个不太美观但有效的解决办法，先匹配头部，根据头部类型判断怎么处理，对空列表则单独处理。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">x <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="string">"nothing"</span></div><div class="line">  <span class="keyword">case</span> head +: _ =&gt; head <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> _:<span class="type">Double</span> =&gt; <span class="string">"do with double"</span></div><div class="line">    <span class="keyword">case</span> _:<span class="type">String</span> =&gt; <span class="string">"do with string"</span></div><div class="line">    <span class="keyword">case</span> _        =&gt; <span class="string">"un-matched"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="10、其他"><a href="#10、其他" class="headerlink" title="10、其他"></a>10、其他</h3><h4 id="1、避免使用枚举来匹配"><a href="#1、避免使用枚举来匹配" class="headerlink" title="1、避免使用枚举来匹配"></a>1、避免使用枚举来匹配</h4><p>用枚举来匹配的坏处是编译器无法判定case语句是否以及全覆盖，只有到了运行时才会抛出MatchError异常。</p>
<h4 id="2、提取想要的值"><a href="#2、提取想要的值" class="headerlink" title="2、提取想要的值"></a>2、提取想要的值</h4><p>以前面的Person和Address为例。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> <span class="type">Persion</span>(name, age, <span class="type">Address</span>(_, state, _)) = <span class="type">Person</span>(<span class="string">"Alice"</span>, <span class="number">25</span>, <span class="type">Address</span>(<span class="string">"1 Lane"</span>, <span class="string">"Chicago"</span>, <span class="string">"USA"</span>))</div></pre></td></tr></table></figure>
<p>想要提取的值都保持在变量name、age等变量里。同样对List也可以有类似操作：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> head +: tail = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line"><span class="comment">// head = 1, tail:List[Int] = List(2,3)</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> head1 +: head2 +: tail = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line"><span class="comment">// head1 = 1, head2 = 2, tail = List(3)</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> <span class="type">Seq</span>(a,b,c) = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line"><span class="comment">// a = 1, b = 2, c = 3</span></div></pre></td></tr></table></figure>
<p>回顾前面的用法，很多时候模式匹配都会用来提取对应的值，再进行相应的处理。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/11/scala-pattern-match/" data-id="cjjwwyg92001h9p66juau1jrc" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模式匹配/">模式匹配</a></li></ul>


    </footer>
  </div>
  
    
<ul id="article-nav" class="nav nav-pills nav-justified">
  
  <li role="presentation">
    <a href="/2016/09/11/scala-for-comprehension/" id="article-nav-older" class="article-nav-link-wrap">
      <i class="fa fa-chevron-left pull-left"></i>
      <span class="article-nav-link-title">Scala的for推导式</span>
    </a>
  </li>
  
  
  <li role="presentation">
    <a href="/2016/09/11/a-refactor-of-threads-calling/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-link-title">记一次多线程调用的重构优化</span>
      <i class="fa fa-chevron-right pull-right"></i>
    </a>
  </li>
  
</ul>


  
</article>




        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>Etiam porta <em>sem malesuada magna</em> mollis euismod. Cras mattis consectetur purus sit amet fermentum. Aenean lacinia bibendum nulla sed consectetur.</p>

</div>


  


  
  <div class="sidebar-module">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/GIT/">GIT</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Hexo/">Hexo</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/List/">List</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Option/">Option</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/brew/">brew</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/bug/">bug</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/for-comprehension/">for-comprehension</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/gc/">gc</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/idea/">idea</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/java/">java</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/mybatis/">mybatis</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/proxy/">proxy</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/python-spider/">python spider</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/scala/">scala</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/偏函数/">偏函数</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/多线程/">多线程</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/教程/">教程</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/枚举/">枚举</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/模式匹配/">模式匹配</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/重构/">重构</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/GIT/" style="font-size: 10px;">GIT</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/List/" style="font-size: 10px;">List</a> <a href="/tags/Option/" style="font-size: 10px;">Option</a> <a href="/tags/brew/" style="font-size: 10px;">brew</a> <a href="/tags/bug/" style="font-size: 10px;">bug</a> <a href="/tags/for-comprehension/" style="font-size: 10px;">for-comprehension</a> <a href="/tags/gc/" style="font-size: 10px;">gc</a> <a href="/tags/idea/" style="font-size: 10px;">idea</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/proxy/" style="font-size: 10px;">proxy</a> <a href="/tags/python-spider/" style="font-size: 10px;">python spider</a> <a href="/tags/scala/" style="font-size: 20px;">scala</a> <a href="/tags/偏函数/" style="font-size: 10px;">偏函数</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/教程/" style="font-size: 10px;">教程</a> <a href="/tags/枚举/" style="font-size: 10px;">枚举</a> <a href="/tags/模式匹配/" style="font-size: 10px;">模式匹配</a> <a href="/tags/重构/" style="font-size: 10px;">重构</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">July 2018</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">March 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/02/">February 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">September 2016</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/07/">July 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/04/">April 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2015/12/">December 2015</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2018/07/22/tune-idea-on-startup/">Idea 启动调优</a>
        </li>
      
        <li>
          <a href="/2018/07/17/find-a-bug-in-scala/">给 Scala 的源码找了一个 bug</a>
        </li>
      
        <li>
          <a href="/2018/07/17/reinstall-brew/">解决代理导致无法重新安装 brew 的问题</a>
        </li>
      
        <li>
          <a href="/2018/03/10/delete-local-git-ssh-config/">解决删除本地的 GIT 账号不生效的问题</a>
        </li>
      
        <li>
          <a href="/2017/02/19/scala-enumeration/">scala 的枚举类型</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2018 Ling0fa 的博客<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>



<script src="/js/script.js"></script>

</body>
</html>
