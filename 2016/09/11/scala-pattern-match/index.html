<!DOCTYPE html>
<html lang=null>
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="null">
  <meta name="keywords" content="undefined">
  
    <link rel="icon" href="">
  
    
  <title>Scala的模式匹配 | Ling0fa 的博客</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="stylesheet" href="/lib/jquery.fancybox.min.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body>
  <header>
  <div class="header-container">
    <a class='logo' href="/">
      <span>Ling0fa 的博客</span>
    </a>
    <ul class="right-header">
      
        <li class="nav-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/about" class="item-link">关于</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/archives" class="item-link">归档</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/tags" class="item-link">标签</a>
          
        </li>
      
    </ul>
  </div>
</header>

  <main id='post'>
  <div class="content">
    <article>
        <section class="content markdown-body">
          <h1>Scala的模式匹配</h1>
          <div class='post-meta'>
            <i class="fa fa-calendar" aria-hidden="true"></i> <time>2016/09/11</time>
            
            
              | 
                  <i class="fa fa-tags" aria-hidden="true"></i>
                
               
  <a href="/tags/#scala" class='tag'>scala</a>

  <a href="/tags/#模式匹配" class='tag'>模式匹配</a>


            
          </div>
          <p><em>本文主要总结模式匹配的用法。<br> 本文内容摘自《Scala程序设计》[美]Dean Wampler Alex Payne，版权归原作者所有。</em></p>
<p>Scala的模式匹配有点像以前接触的switch-case语句，但功能比switch-case丰富很多，是一种强大的“协议”。</p>
<h3 id="1、简单匹配"><a href="#1、简单匹配" class="headerlink" title="1、简单匹配"></a>1、简单匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> bools = <span class="type">Seq</span>(<span class="literal">true</span>, <span class="literal">false</span>)</div><div class="line"><span class="keyword">for</span> (bool &lt;- bools) &#123;</div><div class="line">  bool <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="literal">true</span> =&gt; println(<span class="string">"hello"</span>)</div><div class="line">    <span class="keyword">case</span> <span class="literal">false</span> =&gt; println(<span class="string">"world"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// hello</span></div><div class="line"><span class="comment">// world</span></div></pre></td></tr></table></figure>
<p>case后面没有跟break语句。如果将上面任意一个case语句注释，编译器会抛出MatchError，因为case语句没有包含所有可能出现的情况。</p>
<h3 id="2、match中的值、变量和类型"><a href="#2、match中的值、变量和类型" class="headerlink" title="2、match中的值、变量和类型"></a>2、match中的值、变量和类型</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">  x &lt;- <span class="type">Seq</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3.7</span>, <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="symbol">'four</span>)</div><div class="line">&#125; &#123;</div><div class="line">  <span class="keyword">val</span> str = x <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>          =&gt; <span class="string">"int 1"</span></div><div class="line">    <span class="keyword">case</span> i: <span class="type">Int</span>     =&gt; <span class="string">"other int :"</span> + i                <span class="comment">// 除1以外的所有整数</span></div><div class="line">    <span class="keyword">case</span> d: <span class="type">Double</span>  =&gt; <span class="string">"a double:"</span> + d</div><div class="line">    <span class="keyword">case</span> <span class="string">"one"</span>      =&gt; <span class="string">"String one"</span></div><div class="line">    <span class="keyword">case</span> s: <span class="type">String</span>  =&gt; <span class="string">"other string:"</span> + s</div><div class="line">    <span class="keyword">case</span> unexpected =&gt; <span class="string">"unexpected value:"</span> + unexpected <span class="comment">// 匹配其他的情况，x的值赋值给unexpected，类型为Any</span></div><div class="line">  &#125;</div><div class="line">  println(str)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意上面序列最后一个是Scala的Symbol对象。str的类型是所有case语句返回值类型的最近公共父类。另外，<strong>匹配具体的case语句要出现在匹配宽泛的case语句前</strong>，否则具体的case语句永远没有机会匹配上（编译器也可以识别这种错误）。在匹配Double类型时，为了避免舍入误差导致的无法匹配，可以使用下面的方式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">  x &lt;- <span class="type">Seq</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3.7</span>, <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="symbol">'four</span>)</div><div class="line">&#125; &#123;</div><div class="line">  <span class="keyword">val</span> str = x <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>          =&gt; <span class="string">"int 1"</span></div><div class="line">    <span class="keyword">case</span> _: <span class="type">Int</span>     =&gt; <span class="string">"other int :"</span> + x                </div><div class="line">    <span class="keyword">case</span> _: <span class="type">Double</span>  =&gt; <span class="string">"a double:"</span> + x</div><div class="line">    <span class="keyword">case</span> <span class="string">"one"</span>      =&gt; <span class="string">"String one"</span></div><div class="line">    <span class="keyword">case</span> _: <span class="type">String</span>  =&gt; <span class="string">"other string:"</span> + x</div><div class="line">    <span class="keyword">case</span> _          =&gt; <span class="string">"unexpected value:"</span> + x</div><div class="line">  &#125;</div><div class="line">  println(str)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面使用占位符<code>_</code>替代了变量，使用x来获取匹配的值。编写case语句时有个陷阱，就是编译器会假定大写字母开头的是类型名，小写字母开头的是变量名。如果要引用在前面定义的变量时，用反引号将其括起来，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkY</span></span>(y:<span class="type">Int</span>) = &#123;</div><div class="line">  <span class="keyword">for</span> &#123;</div><div class="line">    x &lt;- <span class="type">Seq</span>(<span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>)</div><div class="line">  &#125; &#123;</div><div class="line">    <span class="keyword">val</span> str = x <span class="keyword">match</span> &#123;</div><div class="line">      <span class="keyword">case</span> `y` =&gt; <span class="string">"found y!"</span></div><div class="line">      <span class="keyword">case</span> i:<span class="type">Int</span> =&gt; <span class="string">"found other"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有时不同的匹配语句需要处理相同的逻辑代码，为了避免冗余，可以使用“|”符号：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> str = x <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> _:<span class="type">Int</span> | <span class="keyword">case</span> _:<span class="type">Double</span> =&gt; <span class="string">"found number:"</span> + x</div><div class="line">  <span class="keyword">case</span> _:<span class="type">Any</span> =&gt; <span class="string">"found other"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、序列的匹配"><a href="#3、序列的匹配" class="headerlink" title="3、序列的匹配"></a>3、序列的匹配</h3><p>先看一个Scala的语法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x +: y = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line"><span class="comment">// x: Int = 1</span></div><div class="line"><span class="comment">// y: List[Int] = List(2, 3)</span></div></pre></td></tr></table></figure>
<p>这里的<code>+:</code>是序列的构造操作符（其实就是一个方法），Scala里以<code>:</code>结尾的方法是向右结合的，所有x只有一个头部，y包含整个尾部。类似的还有<code>++:</code>、<code>/:</code>等。对序列就可以这样匹配：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">seqToString</span></span>[<span class="type">T</span>](seq: <span class="type">Seq</span>[<span class="type">T</span>]): <span class="type">String</span> = seq <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> head +: tail =&gt; <span class="string">s"<span class="subst">$head</span> +: "</span> + seqToString(tail)</div><div class="line">  <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="string">"Nil"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">seqToString(<span class="type">Seq</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>))</div><div class="line"><span class="comment">// String = 2 +: 3 +: 4 +: 1 +: Nil</span></div></pre></td></tr></table></figure>
<p>上面使用<code>+:</code>来<strong>提取</strong>序列的头部和尾部放到head和tail变量里，Seq里也有head和tail方法，和这里的是不一样概念。返回的字符串是头部加尾部的递归调用返回的结果。下面是用Nil来匹配空序列。两个case语句包含了序列可能出现的所有可以匹配的情况，怎么理解呢，序列要么包含一个以上的元素，要么为空，非空的时候可以调用<code>+:</code>，匹配第一个case，空的时候就匹配第二个case，相当于分而治之的思想。<br><code>+:</code>其实是一个单例对象，这个类型只有一个方法，即编译器在case语句中用来提取数据的unapply方法，unapply的示意（非完整）如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>[<span class="type">T</span>, <span class="type">Coll</span>](collection:<span class="type">Coll</span>):<span class="type">Option</span>[(<span class="type">T</span>, <span class="type">Coll</span>)]</div></pre></td></tr></table></figure>
<p>头部类型被推断为T，剩余部分的类型和序列本身类型一致（可能为空序列）。<code>case head +: tail =&gt; …</code>是中缀表达式的写法，对应的形式是<code>case +:(head, tail)</code>，真正调用是<code>+:.unapply(collection)</code>。相对的，使用<code>:+</code>可以达到相反的效果，<code>prefix :+ end</code>前后两个变量分别提取了前N-1个元素和最后一个元素。   </p>
<p>为什么返回的是Option呢？其实这是为了允许在自定义unapply里返回需要的属性，对外隐藏内部的细节，比如年龄、住址什么的，当然也有可能返回None。</p>
<h3 id="4、元组的匹配"><a href="#4、元组的匹配" class="headerlink" title="4、元组的匹配"></a>4、元组的匹配</h3><p>直接举栗子把：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> langs = <span class="type">Seq</span>(</div><div class="line">  (<span class="string">"Scala"</span>, <span class="string">"Martin"</span>),</div><div class="line">  (<span class="string">"Clojure"</span>, <span class="string">"Rich"</span>),</div><div class="line">  (<span class="string">"Lisp"</span>, <span class="string">"John"</span>)</div><div class="line">)</div><div class="line"><span class="keyword">for</span> (tuple &lt;- langs) &#123;</div><div class="line">  tuple <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> (_, <span class="string">"Martin"</span>) =&gt; println(<span class="string">"found Scala"</span>)</div><div class="line">    <span class="keyword">case</span> (lang, name) =&gt; println(<span class="string">s"found other language:<span class="subst">$lang</span> (<span class="subst">$name</span>)"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>匹配元组时可以匹配一部分，lang和name都被推断为String。</p>
<h3 id="5、case中的guard语句"><a href="#5、case中的guard语句" class="headerlink" title="5、case中的guard语句"></a>5、case中的guard语句</h3><p>和for推导式中一样，case语句也可以有guard语句。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i &lt;- <span class="type">Seq</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)) &#123;</div><div class="line">  i <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> _ <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> =&gt; println(<span class="string">"even"</span>)</div><div class="line">    <span class="keyword">case</span> _               =&gt; println(<span class="string">"odd"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6、case类的匹配"><a href="#6、case类的匹配" class="headerlink" title="6、case类的匹配"></a>6、case类的匹配</h3><p>case类的成员都是val修饰的，所以类的对象和元组有点像。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span>(<span class="params">street:<span class="type">String</span>, city:<span class="type">String</span>, country:<span class="type">String</span></span>)</span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name:<span class="type">String</span>, age:<span class="type">Int</span>, address:<span class="type">Address</span></span>)</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> alice = <span class="type">Person</span>(<span class="string">"Alice"</span>, <span class="number">25</span>, <span class="type">Address</span>(<span class="string">"1 Lane"</span>, <span class="string">"Chicago"</span>, <span class="string">"USA"</span>))</div><div class="line"><span class="keyword">val</span> bob   = <span class="type">Person</span>(<span class="string">"Bob"</span>, <span class="number">33</span>, <span class="type">Address</span>(<span class="string">"2 Ave"</span>, <span class="string">"Miami"</span>, <span class="string">"USA"</span>))</div><div class="line"><span class="keyword">val</span> charlie = <span class="type">Person</span>(<span class="string">"Charlie"</span>, <span class="number">21</span>, <span class="type">Address</span>(<span class="string">"3 Ct"</span>, <span class="string">"Boston"</span>, <span class="string">"USA"</span>))</div><div class="line"></div><div class="line"><span class="keyword">for</span> (person &lt;- <span class="type">Seq</span>(alice, bob, charlie)) &#123;</div><div class="line">  person <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Person</span>(<span class="string">"Alice"</span>, <span class="number">25</span>, <span class="type">Address</span>(_, <span class="string">"Chicago"</span>, _)) =&gt; println(<span class="string">"hi Alice"</span>)</div><div class="line">    <span class="keyword">case</span> <span class="type">Person</span>(<span class="string">"Bob"</span>, <span class="number">33</span>, <span class="type">Address</span>(<span class="string">"2 Ave"</span>, <span class="string">"Miami"</span>, <span class="string">"USA"</span>)) =&gt; println(<span class="string">"hi bob"</span>)</div><div class="line">    <span class="keyword">case</span> <span class="type">Person</span>(name, age, _) =&gt; println(<span class="string">s"who is <span class="subst">$name</span>, age is <span class="subst">$age</span>"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里和匹配元组类似，也用了通配符，匹配需要的部分。最后一条匹配其余的情况。匹配case类的原理，其实是调用了case类的unapply方法，返回Option[TupleN[ ]]，N表示类里成员变量个数。</p>
<h3 id="7、可变参数列表的匹配"><a href="#7、可变参数列表的匹配" class="headerlink" title="7、可变参数列表的匹配"></a>7、可变参数列表的匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> lists = <span class="type">Seq</span>(</div><div class="line">  <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),</div><div class="line">  <span class="type">List</span>(<span class="number">4</span>,<span class="number">5</span>)</div><div class="line">)</div><div class="line"><span class="keyword">for</span> (list &lt;- lists) &#123;</div><div class="line">  list <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">List</span>(_, _)         =&gt; println(<span class="string">"2 elements"</span>)</div><div class="line">    <span class="keyword">case</span> <span class="type">List</span>(<span class="number">1</span>, vals @ _*) =&gt; println(<span class="string">"tail:"</span> + vals)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// tail:List(2, 3)</span></div><div class="line"><span class="comment">// 2 elements</span></div></pre></td></tr></table></figure>
<h3 id="8、正则表达式的匹配"><a href="#8、正则表达式的匹配" class="headerlink" title="8、正则表达式的匹配"></a>8、正则表达式的匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> bookRE = <span class="string">""</span><span class="string">"Book: title=([^,]+),\s+issue=(.+)"</span><span class="string">""</span>.r   <span class="comment">// 创建一个正则表达式</span></div><div class="line"><span class="keyword">val</span> catalog = <span class="string">"Book: title=Programming Scala, author=Deam Wampler"</span></div><div class="line"></div><div class="line">catalog <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> bookRE(title, author) =&gt; println(<span class="string">"title is $titile,author is $author"</span>)</div><div class="line">  <span class="keyword">case</span> notmatch              =&gt; println(<span class="string">"not match"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里用title和author来在匹配的同时，提取对应的字符串。</p>
<h3 id="9、模式匹配的漏洞"><a href="#9、模式匹配的漏洞" class="headerlink" title="9、模式匹配的漏洞"></a>9、模式匹配的漏洞</h3><p>考虑下面的匹配语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x match &#123;</div><div class="line">  case s1:Seq[Double] =&gt; println(&quot;Double&quot;)</div><div class="line">  case s2:Seq[String] =&gt; println(&quot;String&quot;)</div><div class="line">  case _              =&gt; println(&quot;unkonwn&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的匹配语句看似没什么问题，其实编译会产生告警。问题出在JVM的类型擦除机制，所以编译器认为第二个case语句不可达。有一个不太美观但有效的解决办法，先匹配头部，根据头部类型判断怎么处理，对空列表则单独处理。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">x <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="string">"nothing"</span></div><div class="line">  <span class="keyword">case</span> head +: _ =&gt; head <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> _:<span class="type">Double</span> =&gt; <span class="string">"do with double"</span></div><div class="line">    <span class="keyword">case</span> _:<span class="type">String</span> =&gt; <span class="string">"do with string"</span></div><div class="line">    <span class="keyword">case</span> _        =&gt; <span class="string">"un-matched"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="10、其他"><a href="#10、其他" class="headerlink" title="10、其他"></a>10、其他</h3><h4 id="1、避免使用枚举来匹配"><a href="#1、避免使用枚举来匹配" class="headerlink" title="1、避免使用枚举来匹配"></a>1、避免使用枚举来匹配</h4><p>用枚举来匹配的坏处是编译器无法判定case语句是否以及全覆盖，只有到了运行时才会抛出MatchError异常。</p>
<h4 id="2、提取想要的值"><a href="#2、提取想要的值" class="headerlink" title="2、提取想要的值"></a>2、提取想要的值</h4><p>以前面的Person和Address为例。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> <span class="type">Persion</span>(name, age, <span class="type">Address</span>(_, state, _)) = <span class="type">Person</span>(<span class="string">"Alice"</span>, <span class="number">25</span>, <span class="type">Address</span>(<span class="string">"1 Lane"</span>, <span class="string">"Chicago"</span>, <span class="string">"USA"</span>))</div></pre></td></tr></table></figure>
<p>想要提取的值都保持在变量name、age等变量里。同样对List也可以有类似操作：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> head +: tail = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line"><span class="comment">// head = 1, tail:List[Int] = List(2,3)</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> head1 +: head2 +: tail = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line"><span class="comment">// head1 = 1, head2 = 2, tail = List(3)</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> <span class="type">Seq</span>(a,b,c) = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line"><span class="comment">// a = 1, b = 2, c = 3</span></div></pre></td></tr></table></figure>
<p>回顾前面的用法，很多时候模式匹配都会用来提取对应的值，再进行相应的处理。</p>

        </section>
    </article>
    
        
  </div>
  <aside>
    
    <div class="toc-container">
        <h1>目录</h1>
        <div class="content">
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、简单匹配"><span class="toc-number">1.</span> <span class="toc-text">1、简单匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、match中的值、变量和类型"><span class="toc-number">2.</span> <span class="toc-text">2、match中的值、变量和类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、序列的匹配"><span class="toc-number">3.</span> <span class="toc-text">3、序列的匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、元组的匹配"><span class="toc-number">4.</span> <span class="toc-text">4、元组的匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、case中的guard语句"><span class="toc-number">5.</span> <span class="toc-text">5、case中的guard语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、case类的匹配"><span class="toc-number">6.</span> <span class="toc-text">6、case类的匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、可变参数列表的匹配"><span class="toc-number">7.</span> <span class="toc-text">7、可变参数列表的匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、正则表达式的匹配"><span class="toc-number">8.</span> <span class="toc-text">8、正则表达式的匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、模式匹配的漏洞"><span class="toc-number">9.</span> <span class="toc-text">9、模式匹配的漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、其他"><span class="toc-number">10.</span> <span class="toc-text">10、其他</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、避免使用枚举来匹配"><span class="toc-number">10.1.</span> <span class="toc-text">1、避免使用枚举来匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、提取想要的值"><span class="toc-number">10.2.</span> <span class="toc-text">2、提取想要的值</span></a></li></ol></li></ol>
        </div>
    </div>
    
  </aside>
</main>



  <footer>
  <div class="copyright">
    <div>
      &copy; 2018 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>&nbsp
    </div>
    <div>
      Theme by <a href="https://github.com/lewis-geek/hexo-theme-Aath" target="_blank">Aath</a>
    </div>
  </div>
</footer>


<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="/lib/in-view.min.js"></script>
<script src="/lib/lodash.min.js"></script>
<script>
  var isDown = true
  var oldY = 0
  inView.offset(50)

  document.body.addEventListener('touchstart', function(){});
  
  window.addEventListener('scroll', _.throttle(e => {
    var currentY = window.scrollY
    if((oldY - currentY) < 0) {
      isDown = true
    } else {
      isDown = false
    }
    oldY = currentY
  }, 250))

  $("article img").each(function() {
      var strA = "<a data-fancybox='gallery' href='" + this.src + "'></a>";
      $(this).wrapAll(strA);
  });

  $('.toc-link').each(function() {
      var href = $(this).attr("href");
      
      inView(href).on('exit', () => {
        if (isDown) {
          handleActive(href)
        }
      })

      inView(href).on('enter', () => {
        if (!isDown) {
          handleActive(href)
        }
      })

      this.onclick = function(e) {
        var pos = $(href).offset().top - 10;
        $("html,body").animate({scrollTop: pos}, 300);
        setTimeout(() => {
          handleActive(href)
        }, 350)
        return false
      }
  })

  function handleActive(href) {
    document.querySelectorAll('.toc-link').forEach(elm => {
      elm.classList.remove('active')
    })
    document.querySelector(".toc [href='"+ href +"']").classList.add('active')
  }
</script>
<script src="/lib/jquery.fancybox.min.js"></script>


</body>
</html>
